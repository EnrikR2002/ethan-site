---
/**
 * Deck-style navigator (flip) for images & videos.
 * Accepts items shaped as { id, type: 'image'|'video', src, title? }
 * Centers one current item; neighbors have spiral/depth effect.
 * Supports scroll, arrow keys, swipe, and on-screen Prev/Next buttons.
 */
const { items = [] } = Astro.props;
---

<style>
  .canvas-viewport {
    position: relative;
    width: 100%;
    height: 70vh;
    overflow: hidden;
    border-radius: 1rem;
    border: 1px solid #e5e7eb;
    background: rgba(255, 255, 255, 0.7);
    backdrop-filter: blur(4px);
    box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05);
    touch-action: pan-y; /* allow page to scroll vertically */
  }
  .canvas-plane {
    position: relative;
    width: 100%;
    height: 100%;
  }
  .deck-item {
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    border-radius: 12px;
    overflow: hidden;
    border: 1px solid rgba(0, 0, 0, 0.08);
    transition:
      transform 220ms ease,
      opacity 220ms ease,
      filter 220ms ease;
    will-change: transform, opacity;
    max-width: min(90vw, 960px);
    max-height: min(70vh, 540px);
    aspect-ratio: 16/9;
    background: #000;
  }
  .deck-item img,
  .deck-item video {
    display: block;
    width: 100%;
    height: 100%;
    object-fit: cover;
  }
  @media (max-width: 640px) {
    .canvas-viewport {
      padding-bottom: 56px;
    }
  }
  @media (prefers-reduced-motion: reduce) {
    .deck-item {
      transition: none !important;
    }
  }
  .canvas-hint {
    position: absolute;
    right: 12px;
    bottom: 12px;
    font-size: 12px;
    opacity: 0.75;
    background: rgba(255, 255, 255, 0.7);
    -webkit-backdrop-filter: blur(4px);
    backdrop-filter: blur(4px);
    padding: 0.25rem 0.5rem; /* px-2 py-1 */
    border-radius: 0.25rem; /* rounded */
  }
  .canvas-controls {
    position: absolute;
    right: 12px;
    top: 12px;
    display: flex;
    gap: 8px;
    z-index: 200;
  }
  .canvas-controls .nav-btn {
    background: rgba(255, 255, 255, 0.85);
    border: 1px solid rgba(0, 0, 0, 0.06);
    padding: 0.35rem 0.6rem;
    border-radius: 6px;
    cursor: pointer;
    font-size: 13px;
  }
  .canvas-ctas {
    position: absolute;
    right: 12px;
    top: 64px;
    display: flex;
    flex-direction: column;
    gap: 8px;
    z-index: 200;
  }
  .canvas-ctas .cta-btn {
    background: rgba(20, 20, 24, 0.95);
    color: white;
    padding: 0.4rem 0.8rem;
    border-radius: 6px;
    font-size: 13px;
    text-decoration: none;
  }
  /* Mobile: place CTAs at bottom center */
  @media (max-width: 640px) {
    .canvas-ctas {
      right: 50%;
      left: 50%;
      transform: translateX(-50%);
      bottom: 12px;
      top: auto;
      flex-direction: row;
    }
    .canvas-controls {
      left: 50%;
      right: auto;
      transform: translateX(-50%);
      bottom: 52px; /* sit just above CTAs */
      top: auto;
    }
  }
  @media (prefers-color-scheme: dark) {
    .canvas-hint {
      background: rgba(24, 24, 27, 0.7); /* zinc-900/70 */
      color: white;
    }
  }
</style>

<div class="canvas-viewport" id="viewport" tabindex="0">
  <div class="canvas-plane" id="plane">
    {
      items.map((it: any, i: number) => (
        <div class="deck-item" data-index={i}>
          {it.type === "image" ? (
            <img
              src={it.src}
              alt={it.title || "Gallery item"}
              loading="lazy"
              decoding="async"
            />
          ) : it.type === "video" ? (
            <video src={it.src} preload="metadata" playsinline />
          ) : (
            // fallback: try video
            <video src={it.src} preload="metadata" playsinline />
          )}
        </div>
      ))
    }
  </div>
  <div class="canvas-controls" role="group" aria-label="Canvas navigation">
    <button id="prev-btn" class="nav-btn" type="button" aria-label="Previous"
      >← Prev</button
    >
    <button id="next-btn" class="nav-btn" type="button" aria-label="Next"
      >Next →</button
    >
  </div>
  <div class="canvas-ctas">
    <button id="showreel-a" class="cta-btn">Play Showreel A</button>
    <button id="showreel-b" class="cta-btn">Play Showreel B</button>
  </div>
  <div class="canvas-hint">Scroll / Swipe / ← → to navigate</div>
</div>

<script>
  // @ts-nocheck
  (function () {
    var viewport = document.getElementById("viewport");
    var plane = document.getElementById("plane");
    if (!viewport || !plane) return;
    var children = Array.prototype.slice.call(
      plane.querySelectorAll(".deck-item")
    );
    var n = children.length;
    if (n === 0) return;
    var current = 0;
    var wheelCooldown = false;
    var swipeStartX = 0;
    var swiping = false;

    function mod(a, b) {
      return ((a % b) + b) % b;
    }
    function signedWrapDistance(i, j, len) {
      var diff = i - j;
      var alt = diff > 0 ? diff - len : diff + len;
      return Math.abs(alt) < Math.abs(diff) ? alt : diff;
    }

    function update() {
      for (var i = 0; i < n; i++) {
        var el = children[i];
        var d = signedWrapDistance(i, current, n); // negative: left, positive: right
        var ad = Math.abs(d);
        var maxShow = 4; // how many neighbors to show before fade
        var s = Math.max(0.5, 1 - 0.12 * ad);
        var offsetX = d * 70; // px shift horizontally
        var offsetY = ad * 18; // slight vertical drift
        var rot = d * 5; // degrees
        var op = ad > maxShow ? 0 : Math.max(0, 1 - 0.22 * ad);
        el.style.transform =
          "translate(-50%, -50%) translate(" +
          offsetX +
          "px," +
          offsetY +
          "px) rotate(" +
          rot +
          "deg) scale(" +
          s +
          ")";
        el.style.opacity = String(op);
        el.style.zIndex = String(100 - ad);
        el.style.pointerEvents = d === 0 ? "auto" : "none";
        if (op === 0) {
          el.style.filter = "blur(2px)";
        } else {
          el.style.filter = "none";
        }
        // video controls only on current
        var v = el.querySelector("video");
        if (v) {
          v.controls = d === 0;
          if (d !== 0) {
            v.pause();
          }
        }
      }
    }

    function next() {
      current = mod(current + 1, n);
      update();
    }
    function prev() {
      current = mod(current - 1, n);
      update();
    }

    // Wheel / trackpad navigate with cooldown
    viewport.addEventListener(
      "wheel",
      function (e) {
        var dy = e.deltaY;
        //if (Math.abs(dy) < 1) return; // ignore tiny jitters, let page scroll
        // Consume the scroll while over the viewport so the page doesn't scroll
        e.preventDefault();
        if (wheelCooldown) return; // do not navigate repeatedly during cooldown
        wheelCooldown = true;
        if (dy > 0) next();
        else prev();
        setTimeout(function () {
          wheelCooldown = false;
        }, 180);
      },
      { passive: false }
    );

    // Arrow keys and Space/Enter
    viewport.addEventListener("keydown", function (e) {
      if (e.key === "ArrowRight" || e.key === "ArrowDown") {
        e.preventDefault();
        next();
      } else if (e.key === "ArrowLeft" || e.key === "ArrowUp") {
        e.preventDefault();
        prev();
      } else if (e.key === " " || e.key === "Spacebar" || e.key === "Enter") {
        e.preventDefault();
        next();
      }
    });

    // Swipe (pointer) left/right
    viewport.addEventListener("pointerdown", function (e) {
      swiping = true;
      swipeStartX = e.clientX;
      viewport.setPointerCapture(e.pointerId);
    });
    viewport.addEventListener("pointerup", function (e) {
      if (!swiping) return;
      var dx = e.clientX - swipeStartX;
      swiping = false;
      if (Math.abs(dx) > 40) {
        if (dx < 0) next();
        else prev();
      }
    });
    viewport.addEventListener("pointercancel", function () {
      swiping = false;
    });

    // Click-to-play current video
    plane.addEventListener("click", function (e) {
      var target = e.target;
      if (!(target instanceof HTMLElement)) return;
      var itemEl = target.closest(".deck-item");
      if (!itemEl) return;
      var idxAttr = itemEl.getAttribute("data-index");
      var idx = idxAttr ? parseInt(idxAttr, 10) : -1;
      if (idx !== current) return;
      var vid = itemEl.querySelector("video");
      if (vid) {
        if (vid.paused) vid.play();
        else vid.pause();
      }
    });

    // Prev/Next button wiring
    var prevBtn = document.getElementById("prev-btn");
    var nextBtn = document.getElementById("next-btn");
    if (prevBtn)
      prevBtn.addEventListener("click", function (e) {
        e.preventDefault();
        prev();
      });
    if (nextBtn)
      nextBtn.addEventListener("click", function (e) {
        e.preventDefault();
        next();
      });

    // Showreel CTAs - simplest behavior: open media in new tab
    var showA = document.getElementById("showreel-a");
    var showB = document.getElementById("showreel-b");
    if (showA)
      showA.addEventListener("click", function (e) {
        e.preventDefault();
        window.open("/media/showreel-a.mp4", "_blank");
      });
    if (showB)
      showB.addEventListener("click", function (e) {
        e.preventDefault();
        window.open("/media/showreel-b.mp4", "_blank");
      });

    // Focus is available via Tab; avoid auto-focus to respect user expectation
    update();
  })();
</script>
